#' @title Data presentation and selection module (UI)
#' @description describe here
#' @param module_header_text \code{character}
#' @details This module shows the user the table generated by \code{\link{data_presentation_and_selection}}. \cr \cr
#' There are the following static UI elements: \cr
#' - \code{textOutput("site_header")} renders the title of the page \cr
#' - \code{actionButton("validate_and_proceed")} finishes work on the step and forces a move down the workflow \cr
#' - \code{actionButton("clear_table_selection")} clears the row selection in table \cr
#' - \code{actionButton("save_selection_as")} saves the selection of series \cr
#' - \code{DT::dataTableOutput("data_selection_table")} prints the table generated in server and described 
#' in \code{\link{data_presentation_and_selection}} \cr 
#' - \code{DT::dataTableOutput("list_of_selections")} prints the names of the time series groups, i.e. 
#' \code{selections} saved by the user, eventually provided in server \code{pre_selected_datasets}.  \cr
#' - \code{actionButton("remove_selection")} removes \code{selection}, or grouping of series, 
#' from \code{"list_of_selections"} \cr
#' \cr
#' There are the following dynamic UI elements, generated in \code{\link{data_presentation_and_selection}}: \cr
#' - box allowing for selecting top/bottom N/percent of stocks based on sorting the table by one of 
#' the \code{value_types_for_display} characteristic names. There are two \code{selectInputs}: 
#' in the box \code{top_or_bottom} and \code{n_or_percent}, and a multiple \code{selectInput} populated 
#' with \code{value_types_for_display} elements.\cr
#' \cr
#' An alternative to generating is using \code{updateSomeElement} functions.
#' @seealso \code{\link{data_presentation_and_selection}}
#' @export 

data_presentation_and_selection_ui <- function(id, module_header_text){
  
}



#' @title Data presentation and selection module (server)
#' @description describe here
#' @param db_pointer descriptor of database to connect to. \code{list} with fields \code{server = c("ss","sdw","dm")} 
#' and \code{db_schema}, which specifies what table to query, for example \code{db_schema="hf_data"}. 
#' The table is then filtered with the use of \code{db_filters} described below.
#' @param value_types_for_display \code{character} vector of data types to be queried from the tidy-formatted database. 
#' Examples we can think of are \code{total_return_index}, \code{ex_dividend_return}, \code{5m_variance_realised}, 
#' \code{5m_high_frequency_return} or \code{capm_beta}... \cr
#' This field could be moved to inputs as well.
#' @param value_types_for_output \code{character} vector of data types to be returned in the tidy-formatted df.
#' \cr This field could be moved to inputs as well
#' @param pre_selected_datasets \code{list} of key:value. The key is tha name of the selection. 
#' The value is a data.frame that contains hashes and names of time series to be picked from the data_base 
#' and passed on inside the function return with the use of the mechanism listed in Details.
#' @param cross_sectional_aggregators_for_output \code{list} of \code{functions} that will be used for 
#' constructing summary statistics for a given time point over the cross-section of selected time series. 
#' Think equally-weighted or value-weighted portfolio creation, mean or median of stock alpha or beta across 
#' selection. Each function will be applied to all value types returned.
#' @param db_filters is a set of filtering expressions to be passed to \code{dplyr::filter_} when querying the 
#' initial db. This allows for arbitrary trimming of the table for the purpose of the exercise that follows: 
#' for example, only take monthly data, limit the sample, etc.
#' @return \code{data.frame} in tidy format. The \code{data.frame} contains series defined via interaction with 
#' queried data table through the \code{DT::datatable} interface. See details for more information.
#' @details This module is designed for listing the contents of a time series database and selecting time series 
#' of interest for analysis. It should facilitate choosing from potentially hundreds/thousands of series with 
#' sorting and filter-based selections. \cr\cr
#' The module assumes a base entity is a financial instrument, be it a stock, an index, or a bond. There are 
#' numerous data types (or value types) associated with each financial instrument: from basic notions like 
#' total return index, or dividend payout, to constructed statistics like factor model betas, realised betas etc. 
#' The table thus has the following minimum set of columns: \code{id} (FIGI, hash, etc.), \code{name} 
#' (in case of long stock series, e.g. last name for given \code{permno} from \code{crsp}), \code{value_type}, 
#' \code{value}, \code{date} (including fractional seconds, this might have to deal with HF tables, too), 
#' \code{frequency}. \cr\cr
#' The module first connects to database specified by \code{db_pointer} \cr\cr
#' Based on information in \code{input$characteristics_base_date} the module queries for descriptive data about 
#' the series, as specified in the \code{value_types_for_display} vector. For example, one can think of pulling 
#' series names alongside information on market capitalization, book/market ratio and capm beta that are available 
#' at the date nearest to \code{input$characteristics_base_date}. Group by series and select information only for 
#' a single date. \cr\cr
#' The queried information is moved to a wide format and pushed to \code{output$selection_table}, plus stored 
#' within the function. The \code{output$selection_table} has one row per \code{id x frequency}.\cr\cr
#' Series selection is based on mechanisms from the \code{DT} package. Click-based selections are validated 
#' with an action button and saved to a user-named selection, in \code{output$list_of_selections}. 
#' The user can also select based on top- or bottom- selections by univariate rankings based on 
#' \code{value_types_for_display}. Each selection is validated/added by button click and named by the user. \cr
#' Based on the validated selections, and on the \code{value_types_for_output} vector, the module queries 
#' the database and fetches time-series information. A number of constructed series is appended to the returned 
#' tidy \code{data.frame} with the use of \code{cross_sectional_aggregators_for_output}. The following columns 
#' are appended to the tidy dataset: \code{selection}, indicating that the chosen series belongs to one of the 
#' user's selections (a series can be selected multiple times!). Aggregate series are appended to the dataset with 
#' \code{value_type} based on original \code{value_type}.
#' @seealso \code{\link{data_presentation_and_selection_ui}}
#' @export

data_presentation_and_selection <- function(input, output, session, db_pointer, pre_selected_datasets, value_types_for_display, value_types_for_output, cross_sectional_aggregators, db_filters){
  
  result_data_frame <- data.frame()
  
  return(result_data_frame)
}