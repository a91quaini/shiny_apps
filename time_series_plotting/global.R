#### UI
#' @title Time series plotting module (UI)
#' @description Based on a tidy \code{data.frame} of time series data, the module plots the series and allows 
#' for selecting series / groups of series to be plotted.
#' @param module_header_text \code{character}, defines some local module title.
#' @details This module shows the user the table generated by \code{\link{data_presentation_and_selection}}. \cr \cr
#' There are the following static UI elements: \cr
#' - \code{textOutput("site_header")} renders the title of the page \cr
#' - \code{actionButton("validate_and_proceed")} finishes work on the step and forces a move down the workflow \cr
#' - \code{DT::dataTableOutput("list_of_tags")} prints the names of the time series \code{tags} chosen by the user. 
#' It is from this table that elements for plotting are selected. 
#' Clicking on a series in the plot area highlights it in this table. \cr
#' - \code{DT::dataTableOutput("list_of_series")} where from the user picks individual series to be plotted. \cr
#' - the plotting area. Time series plots. \code{plotOutput("ts_plot")} or \code{plotly::plotlyOutput("ts_plot")}. \cr
#' - \code{textOutput("clicked_series")}: name of series that was selected by in in-plot click
#' \cr
#' There are the following dynamic UI elements, generated in \code{\link{time_series_plotting}}: \cr
#' - A \code{selectInput} (multiple) box with \code{value_types} which should be plotted, 
#' which are populated from the \code{value_type} column of \code{time_series_data} in the server function 
#' \code{\link{time_series_plotting}}. This is accompanied by a \code{checkBox} highlight option to highlight 
#' aggregated series in plots, and grey out the individual components.
#' \cr \cr
#' An alternative to generating is using \code{updateSomeElement} functions.
#' @seealso \code{\link{time_series_plotting}}
#' @export



time_series_plotting_ui <- function(id, module_header_text){
  ns <- NS(id)
  
  tagList(
    
    # plot area
    fluidRow(
      tags$h1(module_header_text),
      
      sidebarLayout(
        sidebarPanel(
          # selectizeInput tag
          selectizeInput(ns("tags"), choices = NULL,
                         label = "Choose tags", multiple = TRUE),
          
          # checkBox highlight
          uiOutput(ns("highlight")),
          
          # selectizeInput value type
          selectizeInput(ns("value_type"), choices = NULL,
                         label = "Choose value type"),
          
          # selectizeInput frequency
          selectizeInput(ns("frequency"), choices = NULL,
                         label = "Choose frequency"),
          
          # select date range
          dateRangeInput(ns("date_range"), "Choose date range")
        ),
        
        mainPanel(
          # plot
          plotOutput(ns("ts_plot"), click = ns("plot_click"))
        )
      )
    ),
    
    # data table area
    fluidRow(
      sidebarLayout(
        sidebarPanel(
          # textOutput of selected series
          uiOutput(ns("help_clicked_series")),
          verbatimTextOutput(ns("clicked_series")),
          
          # actionbutton show table
          uiOutput(ns("show_table"))
        ),
        
        mainPanel(
          # dataTable of series
          DT::dataTableOutput(ns("series_table"))
        )
      )
      
      
    )
  )
  
}

#### SERVER
#' @title Time series plotting module (server)
#' @description Plot time series of potentially multiple categories from tidy \code{data.frame}
#' @param time_series_data tidy \code{data.frame} that is the output of \code{\link{data_presentation_and_selection}}. 
#' The standard tidy dataset has to contain a \code{selection} column for gouping of variables / portoflios in the plots.
#' @param tagging_data \code{data.frame} that contains information about the grouping of data for aggregate/cross-sectional 
#' plotting. This table is formed at the financial instrument level. It has two columns: \code{id} and \code{tag}. 
#' You can have multiple \code{ids} per \code{tag} and vice versa.
#' @param value_type_line_type is a device for determining how to plot which element. 
#' \code{data.frame} with columns \code{value_type} and \code{line_type}. 
#' We have to determine a mechanism to have it work with the chosen plotting platform.
#' @return The function passes on the \code{time_series_data} structure.
#' @details The plotting should use either the standard device, or \code{ggplot2} or \code{plotly}. 
#' The chosen technolgy should allow for picking series from picture on click. 
#' Get inspired by \url{https://plot.ly/r/shiny-coupled-events/} and \url{https://shiny.rstudio.com/articles/plot-interaction.html}.
#' @export


time_series_plotting <- function(input, output, session, time_series_data, tagging_data, value_type_line_type){
  
  ns <- session$ns
  
  #### plot
  ##############
  
  # selectizeInput tags
  observeEvent({
    tagging_data()
    time_series_data()
  }, {
    tag_vector <- tagging_data() %>%
      select(tag) %>%
      distinct() %>% .[[1]]
    
    updateSelectizeInput(session, "tags",
                         choices = tag_vector,
                         server = TRUE)
    
    value_type_vector <- time_series_data() %>%
      select(value_type) %>%
      distinct() %>% .[[1]]
    
    updateSelectizeInput(session, "value_type",
                         choices = value_type_vector,
                         selected = value_type_vector[1],
                         server = TRUE)
    
    date_vector <- time_series_data() %>%
      select(date) %>%
      distinct() %>% .[[1]]
    min_date <- min(date_vector)
    max_date <- max(date_vector)
    
    updateDateRangeInput(session, "date_range",
                         start = min_date, end = max_date,
                         min = min_date, max = max_date)
  })
  
  observeEvent(input$value_type, {
    frequency_vector <- time_series_data() %>%
      filter(value_type %in% input$value_type) %>%
      select(frequency) %>%
      distinct() %>%.[[1]]
    
    updateSelectizeInput(session, "frequency",
                         choices = frequency_vector,
                         selected = frequency_vector[1],
                         server = TRUE)
  })
  
  # checkBox highlight
  output$highlight <- renderUI({
    req(input$tags)
    
    checkboxInput(ns("highlighter"), "Highlight series")
  })
  
  # reactive (to all previous choices) dataframe for plotting
  plot_dataframe <- reactive({
    validate(need(input$tags, "Tags"))
    validate(need(input$value_type, "Value type"))
    validate(need(input$date_range, "Date range"))
    validate(need(input$frequency, "Frequency"))
    
    
    # ids corresponding to chosen tags
    id_vector <- tagging_data() %>%
      filter(tag %in% input$tags) %>%
      select(id) %>% .[[1]]
    
    time_series_data() %>%
      filter(id %in% id_vector,
             value_type %in% input$value_type,
             frequency %in% input$frequency,
             date %in% seq.Date(from = min(input$date_range),
                                to = max(input$date_range),
                                by = "day"))
  })
  
  # plot
  output$ts_plot <- renderPlot({
    ggplot(data = plot_dataframe()) +
      geom_line(mapping = aes(x = date, y = value, color = name))
  })
  
  #### data table
  ###############
  
  # reactive (to series selected from plot) vector with one column of names
  name_vector <- reactive({
    req(input$plot_click)
    nearPoints(plot_dataframe(), input$plot_click,
               threshold = 10, maxpoints = 1, addDist = TRUE) %>%
      select(name) %>% .[[1]]
  })
  
  # textOutput selected series + help text
  output$help_clicked_series <- renderUI({
    req(name_vector())
    helpText("Selected series")
  })
  
  # textOutput clicked series
  output$clicked_series <- renderText({
    paste0(name_vector())
  })
  
  # actionButton show table
  output$show_table <- renderUI({
    req(name_vector())
    
    checkboxInput(ns("table_button"), "Show data table", value = TRUE)
  })
  
  # data table dataframe
  table_dataframe <- reactive({
    req(name_vector())
    validate(need(input$table_button, "Table button"))
    
    plot_dataframe() %>%
      filter(name %in% name_vector()) %>%
      select(id, name, currency) %>%
      distinct()
  })
  
  # data table
  output$series_table <- DT::renderDataTable({
    DT::datatable( table_dataframe() )
  })
  
  
  # return(time_series_data)
  
}